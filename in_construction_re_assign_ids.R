#Problem: 'cat' or 'reach_id' in the shapefile, associated with lines across 
#confluences. Makes it impossible to correctly use network hydrology data.

#There are three spatial units in this code:
#Segment sections: uniquely identified by UID, these are the individual lines
#                 contained in the shapefile generated by WP1 after hydrological
#                 modeling.
#Segments: uniquely identifed by UID_fullseg, representing lines extending between 
#           two confluences. They often contain multiple sections.
#Cat: uniquely identified by cat (or reach_id), these are unique reaches as modeled
#     by the hydrological model, but not well represented/assigned to segment
#     sections  in the shapefile. Some may be omitted by the shapefile, 
#     many span multiple segment sections and even multiple segments across 
#     confluences and Strahler stream order.

#The goal of this function is to re-assign a topologically/hydrologically
#logical cat to each segment section to be able to join the hydrological model 
#outputs to the shapefile.

#Parameters
in_country <- 'Croatia'
rivnet_path <- tar_read(network_ssnready_gpkg_list)[[in_country]]
strahler_dt <- tar_read(network_strahler)[[in_country]] 
in_reaches_dt <- tar_read(reaches_dt)[country==in_country,] 

#Helper functions
#For those segments where only one cat remains, assign cat to the entire segment
assign_singlecat_to_seg <- function(net_dt, length_threshold = 1/3) {
  # Identify segments with only one remaining section
  #with a cat (length_uid_fullsegper == 1) and where the actual length of that
  #section is at least a given proportion of the length of the full segment
  #including all sections.
  cat_toassign <- net_dt[
    is.na(cat_cor) & (length_uid_fullsegper == 1) &
      (length_uid / length_fullseg > length_threshold),
    .(UID_fullseg, cat)
  ] %>%
    setnames('cat', 'cat_cor')
  
  #Assign those cat_cor to all sections within those segments
  net_dt[is.na(cat_cor), 
         cat_cor := cat_toassign[.SD, on = 'UID_fullseg', cat_cor]]
}

#---------------------------- FUNCTION -----------------------------------------
#---------- Prepare data -------------------------------------------------------
#Format hydromod reaches data
in_reaches_dt <- in_reaches_dt[, .(ID, to_reach, length)] %>%
  setnames(c('ID_hydromod', 'to_reach_hydromod', 'length_hydromod'))

#Read network and join with hydromod data
rivnet <- st_read(rivnet_path) %>%
  merge(strahler_dt, by='UID') %>%
  merge(in_reaches_dt, by.x='cat', by.y='ID_hydromod')

#Remove pseudonodes to define full segments between confluences
rivnet_fullseg <- as_sfnetwork(rivnet) %>%
  activate("edges") %>%
  convert(to_spatial_smooth) %>%
  st_as_sf() 
#Give these full segments between confluences a separate ID: UID_fullseg
rivnet_fullseg$UID_fullseg <- seq_len(nrow(rivnet_fullseg))

#Intersect with original network to check length of overlap for each 'cat'
rivnet_fullseg_inters <- st_intersection(
  rivnet, rivnet_fullseg[, c('geometry', 'UID_fullseg')]) %>%
  .[st_geometry_type(.) != 'POINT',] %>%
  st_cast('MULTILINESTRING') %>%
  st_cast('LINESTRING')

#Remove pseudo-nodes among segments sections of the same cat
rivnet_fullseg_inters_nopseudo <- as_sfnetwork(rivnet_fullseg_inters) %>%
  activate(edges) %>%
  convert(to_spatial_smooth, 
          require_equal = c("cat", "UID_fullseg"),
          summarise_attributes = "first") %>%
  st_as_sf()

#Compute length of segment sections (UID)
rivnet_fullseg_inters_nopseudo$length_uid <- as.numeric(
  st_length(rivnet_fullseg_inters_nopseudo))

#Create data.table to work with
rivnet_inters_dt <- as.data.table(rivnet_fullseg_inters_nopseudo) 

#Back up cat before editing it
rivnet_inters_dt[, cat_copy := cat]

#Compute other lengths
rivnet_inters_dt[, length_cat := sum(length_uid), by=cat]
rivnet_inters_dt[, length_fullseg := sum(length_uid), by=UID_fullseg]

#Compute the percentage length of that cat ("hydromod" reach) that is 
#represented by that segment section (identified by UID)
rivnet_inters_dt[, length_uid_catper := length_uid/length_cat]
#Check whether this is the largest segment section for that cat 
rivnet_inters_dt[, length_uid_catmax := (length_uid == max(length_uid)), by=cat]
#Compute the percentage length of that full segment that is represented by
#that segment section (identified by UID)
rivnet_inters_dt[, length_uid_fullsegper := length_uid/length_fullseg]

#Computer number of full segments that a cat overlaps
rivnet_inters_dt[, n_seg_overlap := length(unique(UID_fullseg)), by=cat]


#---------- Assign correct cat -------------------------------------------------
#For first order segments where the cat is only represented by that segment,
#keep that cat for this section of the segment (see cat==2938 for Croatia)
rivnet_inters_dt[n_seg_overlap == 1 & strahler == 1, 
                 cat_cor := cat]
cats_assigned <- rivnet_inters_dt[!is.na(cat_cor), unique(cat_cor)]

#For full segments that only have one cat associated with them, confirm cat
rivnet_inters_dt[length_uid == length_fullseg, 
                 cat_cor := cat]
cats_assigned <- rivnet_inters_dt[!is.na(cat_cor), unique(cat_cor)]

#For cats that are already assigned, remove their "cat" from other segments
rivnet_inters_dt[cat %in% cats_assigned & is.na(cat_cor), cat := NA]

#Re-compute length_uid_fullsegper, excluding segment sections whose initial
#cat was assigned elsewhere
rivnet_inters_dt[!is.na(cat), 
                 length_uid_fullsegper := length_uid/sum(length_uid),
                 by=UID_fullseg]

#For those segments where only one cat remains, assign cat to the entire segment
assign_singlecat_to_seg(rivnet_inters_dt)
cats_assigned <- rivnet_inters_dt[!is.na(cat_cor), unique(cat_cor)]

#For cats that are already assigned, remove their "cat" from other segments
rivnet_inters_dt[cat %in% cats_assigned & is.na(cat_cor), cat := NA]

#For segment section with cat==NAs in first order streams, assign cat_cor of
#upstream segment
cat_cor_toassign <- rivnet_inters_dt[
  !is.na(cat_cor) & (strahler == 1) & 
    (to %in% rivnet_inters_dt[is.na(cat) & strahler == 1, unique(from)]), 
  .(to, UID_fullseg, cat_cor)] %>%
  setnames('to', 'from')
rivnet_inters_dt[is.na(cat) & strahler == 1,
                 cat_cor := cat_cor_toassign[
                   .SD, on=c('from', 'UID_fullseg'), cat_cor]]

#Re-compute length_uid_fullsegper, excluding segment sections whose initial
#cat was assigned elsewhere
rivnet_inters_dt[!is.na(cat), 
                 length_uid_fullsegper := length_uid/sum(length_uid),
                 by=UID_fullseg]

#For those segments where only one cat remains, assign cat to the entire segment
assign_singlecat_to_seg(rivnet_inters_dt)
cats_assigned <- rivnet_inters_dt[!is.na(cat_cor), unique(cat_cor)]

#For cats that are already assigned, remove their "cat" from other segments
rivnet_inters_dt[cat %in% cats_assigned & is.na(cat_cor), cat := NA]

#Computer number of full segments that a cat overlaps
rivnet_inters_dt[, n_seg_overlap := length(unique(UID_fullseg)), by=cat]

#For second order segments where the cat is only represented by that segment,
#keep that cat for this section of the segment
rivnet_inters_dt[n_seg_overlap == 1 & strahler <= 2 & is.na(cat_cor), 
                 cat_cor := cat]

cats_assigned <- rivnet_inters_dt[!is.na(cat_cor), unique(cat_cor)]

#For cats that are already assigned, remove their "cat" from other segments
rivnet_inters_dt[cat %in% cats_assigned & is.na(cat_cor), cat := NA]

#For segment section with cat==NAs in first order streams, assign cat_cor of
#upstream segment
cat_cor_toassign <- rivnet_inters_dt[
  !is.na(cat_cor) & (strahler == 1) & 
    (to %in% rivnet_inters_dt[is.na(cat) & strahler == 1, unique(from)]), 
  .(to, UID_fullseg, cat_cor)] %>%
  setnames('to', 'from')
rivnet_inters_dt[is.na(cat) & strahler == 1,
                 cat_cor := cat_cor_toassign[
                   .SD, on=c('from', 'UID_fullseg'), cat_cor]]

#Re-compute length_uid_fullsegper, excluding segment sections whose initial
#cat was assigned elsewhere
rivnet_inters_dt[!is.na(cat), 
                 length_uid_fullsegper := length_uid/sum(length_uid),
                 by=UID_fullseg]

#For those segments where only one cat remains, assign cat to the entire segment
assign_singlecat_to_seg(rivnet_inters_dt)
cats_assigned <- rivnet_inters_dt[!is.na(cat_cor), unique(cat_cor)]

#For cats that are already assigned, remove their "cat" from other segments
rivnet_inters_dt[cat %in% cats_assigned & is.na(cat_cor), cat := NA]

#For sections that represent over 75% of the total length of that cat, assign cat_cor
rivnet_inters_dt[length_uid_catper>0.7 & is.na(cat_cor), cat_cor := cat]


#For cats that are already assigned, remove their "cat" from other segments
rivnet_inters_dt[cat %in% cats_assigned & is.na(cat_cor), cat := NA]

#Re-compute length_uid_fullsegper, excluding segment sections whose initial
#cat was assigned elsewhere
rivnet_inters_dt[!is.na(cat), 
                 length_uid_fullsegper := length_uid/sum(length_uid),
                 by=UID_fullseg]

#For those segments where only one cat remains, assign cat to the entire segment
assign_singlecat_to_seg(rivnet_inters_dt)
cats_assigned <- rivnet_inters_dt[!is.na(cat_cor), unique(cat_cor)]

#For cats that are already assigned, remove their "cat" from other segments
rivnet_inters_dt[cat %in% cats_assigned & is.na(cat_cor), cat := NA]

#For segment sections in strahler==1 & n_seg_overlap > 2, cat := NA
rivnet_inters_dt[strahler == 1 & n_seg_overlap > 2 & is.na(cat_cor), 
                 cat := NA] 

#if only representative of cat, assign cat_cor
rivnet_inters_dt[!is.na(cat_cor), cat := cat_cor]
rivnet_inters_dt[, length_cat := sum(length_uid), by=cat]
rivnet_inters_dt[, length_uid_catper := length_uid/length_cat, by=cat]
rivnet_inters_dt[length_uid_catper > 0.7 & is.na(cat_cor), cat_cor := cat]

#For cats that are already assigned, remove their "cat" from other segments
cats_assigned <- rivnet_inters_dt[!is.na(cat_cor), unique(cat_cor)]
rivnet_inters_dt[cat %in% cats_assigned & is.na(cat_cor), cat := NA]

#Re-compute length_uid_fullsegper, excluding segment sections whose initial
#cat was assigned elsewhere
rivnet_inters_dt[!is.na(cat_cor), 
                 length_uid_fullsegper := length_uid/sum(length_uid),
                 by=UID_fullseg]
cat_cor_toassign <-  rivnet_inters_dt[
  is.na(cat_cor) & length_uid_fullsegper == 1,
  .(UID_fullseg, cat)] %>%
  setnames('cat', 'cat_cor')
rivnet_inters_dt[is.na(cat_cor), 
                 cat_cor := cat_cor_toassign[.SD, on='UID_fullseg', 
                                                   cat_cor]]

#For the remaining segments with all NAs, 
#assign the cat of the section representing the highest percent of the segment
rivnet_inters_dt[is.na(cat_cor), NAlength := sum(length_uid),
                 by=UID_fullseg]
rivnet_inters_dt[(NAlength==length_fullseg), 
                 cat_cor := fifelse(length_uid == max(length_uid), cat_copy, NA), 
                 by=UID_fullseg]

#For all remaining sections, remove their "cat" 
rivnet_inters_dt[is.na(cat_cor), cat := NA]

for (i in 1:2) {
  #For segment section with cat==NAs and cat_cor==NA, 
  #assign cat_cor of upstream segment of same strahler order
  cat_cor_toassign <- rivnet_inters_dt[
    !is.na(cat_cor) &
      (from %in% rivnet_inters_dt[is.na(cat) & is.na(cat_cor), unique(to)]), 
    .(from, UID_fullseg, cat_cor, strahler)] %>%
    setnames('from', 'to')
  rivnet_inters_dt[is.na(cat) & is.na(cat_cor),
                   cat_cor := cat_cor_toassign[
                     .SD, on=c('to', 'UID_fullseg'), cat_cor]]
  
  #For is.na(cat) & is.na(cat_cor), 
  #assign downstream cat_cor of same UID_fullseg
  cat_cor_toassign <- rivnet_inters_dt[
    !is.na(cat_cor) &
      (to %in% rivnet_inters_dt[is.na(cat) & is.na(cat_cor), unique(from)]), 
    .(to, UID_fullseg, cat_cor, strahler)] %>%
    setnames('to', 'from')
  rivnet_inters_dt[is.na(cat) & is.na(cat_cor),
                   cat_cor := cat_cor_toassign[
                     .SD, on=c('from', 'UID_fullseg'), cat_cor]]
}

#Check
write_sf(merge(rivnet_fullseg_inters_nopseudo, 
               rivnet_inters_dt[, .(cat_cor, UID)],
               by='UID')[, c('UID', 'cat', 'strahler', 'UID_fullseg', 'cat_cor')],
         file.path(resdir, 'scratch.gdb'), layer='test_1')
