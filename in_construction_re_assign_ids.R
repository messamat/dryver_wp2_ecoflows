#Problem: 'cat' or 'reach_id' in the shapefile, associated with lines across 
#confluences. Makes it impossible to correctly use network hydrology data.

#There are three spatial units in this code:
#Segment sections: uniquely identified by UID, these are the individual lines
#                 contained in the shapefile generated by WP1 after hydrological
#                 modeling.
#Segments: uniquely identifed by UID_fullseg, representing lines extending between 
#           two confluences. They often contain multiple sections.
#Cat: uniquely identified by cat (or reach_id), these are unique reaches as modeled
#     by the hydrological model, but not well represented/assigned to segment
#     sections  in the shapefile. Some may be omitted by the shapefile, 
#     many span multiple segment sections and even multiple segments across 
#     confluences and Strahler stream order.

#The goal of this function is to re-assign a topologically/hydrologically
#logical cat to each segment section to be able to join the hydrological model 
#outputs to the shapefile.

#Parameters
in_country <- 'Croatia'
rivnet_path <- tar_read(network_ssnready_gpkg_list)[[in_country]]
strahler_dt <- tar_read(network_strahler)[[in_country]] 
in_reaches_hydromod_dt <- tar_read(reaches_dt)[country==in_country,] 

#Helper functions
#For those segments where only one cat remains, assign cat to the entire segment
#at least a given proportion of the length of the full segment
assign_singlecat_to_seg <- function(net_dt, length_threshold = 1/3) {
  # Identify segments with only one remaining section
  #with a cat (length_uid_fullsegper == 1) and where the actual length of that
  #section is at least a given proportion of the length of the full segment
  #including all sections.
  cat_toassign <- net_dt[
    is.na(cat_cor) & (length_uid_fullsegper == 1) &
      (length_uid / length_fullseg > length_threshold),
    .(UID_fullseg, cat)
  ] %>%
    setnames('cat', 'cat_cor')
  
  #Assign those cat_cor to all sections within those segments
  net_dt[is.na(cat_cor), 
         cat_cor := cat_toassign[.SD, on = 'UID_fullseg', cat_cor]]
}

#For segment sections with cat==NAs and cat_cor==NA, 
#get cat_cor from upstream section in the same segment
get_nearby_cat <- function(in_dt, source_direction, strahler_list = seq(1,15)) {
  if (source_direction == 'upstream') {
    source_col <- 'to' #Column of section to get cat_cor from
    sink_col <- 'from' #Column of section to assign cat_cor to
  } else if (source_direction == 'downstream') {
    source_col <- 'from' #Column of section to get cat_cor from
    sink_col <- 'to' #Column of section to assign cat_cor to
  }
  
  sections_tofill <- rivnet_inters_dt[
    , which(is.na(cat) &  is.na(cat_cor) & (strahler %in% strahler_list))]
  
  cat_cor_toassign <- rivnet_inters_dt[
    !is.na(cat_cor) & 
      (strahler %in% strahler_list) & 
      (get(source_col) %in% rivnet_inters_dt[sections_tofill, unique(get(sink_col))]), 
    c(source_col, 'UID_fullseg', 'cat_cor'), with=F] %>%
    setnames(source_col, sink_col)
  
  rivnet_inters_dt[sections_tofill,
                   cat_cor := cat_cor_toassign[
                     .SD, on=c(sink_col, 'UID_fullseg'), cat_cor]]
}

#---------------------------- FUNCTION -----------------------------------------
#---------- Prepare data -------------------------------------------------------
#Read network and join with hydromod data
rivnet <- st_read(rivnet_path) %>%
  merge(strahler_dt, by='UID') 

#Remove pseudonodes to define full segments between confluences
rivnet_fullseg <- as_sfnetwork(rivnet) %>%
  activate("edges") %>%
  convert(to_spatial_smooth) %>%
  st_as_sf() 
#Give these full segments between confluences a separate ID: UID_fullseg
rivnet_fullseg$UID_fullseg <- seq_len(nrow(rivnet_fullseg))

#Intersect with original network to check length of overlap for each 'cat'
rivnet_fullseg_inters <- st_intersection(
  rivnet, rivnet_fullseg[, c('geometry', 'UID_fullseg')]) %>%
  .[st_geometry_type(.) != 'POINT',] %>%
  st_cast('MULTILINESTRING') %>%
  st_cast('LINESTRING')

#Remove pseudo-nodes among segments sections of the same cat
rivnet_fullseg_inters_nopseudo <- as_sfnetwork(rivnet_fullseg_inters) %>%
  activate(edges) %>%
  convert(to_spatial_smooth, 
          require_equal = c("cat", "UID_fullseg"),
          summarise_attributes = "first") %>%
  st_as_sf()

#Compute length of segment sections (UID)
rivnet_fullseg_inters_nopseudo$length_uid <- as.numeric(
  st_length(rivnet_fullseg_inters_nopseudo))

#Create data.table to work with
rivnet_inters_dt <- as.data.table(rivnet_fullseg_inters_nopseudo) 

#Back up cat before editing it
rivnet_inters_dt[, cat_copy := cat]

#Compute other lengths
rivnet_inters_dt[, length_cat := sum(length_uid), by=cat]
rivnet_inters_dt[, length_fullseg := sum(length_uid), by=UID_fullseg]

#Compute the percentage length of that cat ("hydromod" reach) that is 
#represented by that segment section (identified by UID)
rivnet_inters_dt[, length_uid_catper := length_uid/length_cat]
#Check whether this is the largest segment section for that cat 
rivnet_inters_dt[, length_uid_catmax := (length_uid == max(length_uid)), by=cat]
#Compute the percentage length of that full segment that is represented by
#that segment section (identified by UID)
rivnet_inters_dt[, length_uid_fullsegper := length_uid/length_fullseg]

#Computer number of full segments that a cat overlaps
rivnet_inters_dt[, n_seg_overlap := length(unique(UID_fullseg)), by=cat]


#---------- Assign correct cat -------------------------------------------------
#For first order segments where the cat is only represented by that segment,
#keep that cat for this section of the segment (see cat==2938 for Croatia)
rivnet_inters_dt[n_seg_overlap == 1 & strahler == 1, 
                 cat_cor := cat]
cats_assigned <- rivnet_inters_dt[!is.na(cat_cor), unique(cat_cor)]

#For full segments that only have one cat associated with them, confirm cat
rivnet_inters_dt[length_uid == length_fullseg, 
                 cat_cor := cat]
cats_assigned <- rivnet_inters_dt[!is.na(cat_cor), unique(cat_cor)]

#For cats that are already assigned, remove their "cat" from other segments
rivnet_inters_dt[cat %in% cats_assigned & is.na(cat_cor), cat := NA]

#Re-compute length_uid_fullsegper, excluding segment sections whose initial
#cat was assigned elsewhere
rivnet_inters_dt[!is.na(cat), 
                 length_uid_fullsegper := length_uid/sum(length_uid),
                 by=UID_fullseg]

#For those segments where only one cat remains, assign cat to the entire segment
assign_singlecat_to_seg(rivnet_inters_dt)
cats_assigned <- rivnet_inters_dt[!is.na(cat_cor), unique(cat_cor)]

#For cats that are already assigned, remove their "cat" from other segments
rivnet_inters_dt[cat %in% cats_assigned & is.na(cat_cor), cat := NA]

#For segment sections with cat==NAs and cat_cor==NA in first order streams, 
#get cat_cor from upstream segment in same segment
get_nearby_cat(rivnet_inters_dt, source_direction = 'upstream', strahler_list = 1) 

#Re-compute length_uid_fullsegper, excluding segment sections whose initial
#cat was assigned elsewhere
rivnet_inters_dt[!is.na(cat), 
                 length_uid_fullsegper := length_uid/sum(length_uid),
                 by=UID_fullseg]

#For those segments where only one cat remains, assign cat to the entire segment
assign_singlecat_to_seg(rivnet_inters_dt)
cats_assigned <- rivnet_inters_dt[!is.na(cat_cor), unique(cat_cor)]

#For cats that are already assigned, remove their "cat" from other segments
rivnet_inters_dt[cat %in% cats_assigned & is.na(cat_cor), cat := NA]

#Computer number of full segments that a cat overlaps
rivnet_inters_dt[, n_seg_overlap := length(unique(UID_fullseg)), by=cat]

#For first and second order segments where the cat is now only represented 
#by that segment, keep that cat for this section of the segment
rivnet_inters_dt[n_seg_overlap == 1 & strahler <= 2 & is.na(cat_cor), 
                 cat_cor := cat]
cats_assigned <- rivnet_inters_dt[!is.na(cat_cor), unique(cat_cor)]

#For cats that are already assigned, remove their "cat" from other segments
rivnet_inters_dt[cat %in% cats_assigned & is.na(cat_cor), cat := NA]

#For segment section with cat==NAs in first order streams, assign cat_cor of
#upstream segment
get_nearby_cat(rivnet_inters_dt, source_direction = 'upstream', strahler_list = 1) 

#Re-compute length_uid_fullsegper, excluding segment sections whose initial
#cat was assigned elsewhere
rivnet_inters_dt[!is.na(cat), 
                 length_uid_fullsegper := length_uid/sum(length_uid),
                 by=UID_fullseg]

#For those segments where only one cat remains, assign cat to the entire segment
assign_singlecat_to_seg(rivnet_inters_dt)
cats_assigned <- rivnet_inters_dt[!is.na(cat_cor), unique(cat_cor)]

#For cats that are already assigned, remove their "cat" from other segments
rivnet_inters_dt[cat %in% cats_assigned & is.na(cat_cor), cat := NA]

#For sections that represent over 75% of the total length of that cat, assign cat_cor
rivnet_inters_dt[length_uid_catper>0.7 & is.na(cat_cor), cat_cor := cat]

#For cats that are already assigned, remove their "cat" from other segments
rivnet_inters_dt[cat %in% cats_assigned & is.na(cat_cor), cat := NA]

#Re-compute length_uid_fullsegper, excluding segment sections whose initial
#cat was assigned elsewhere
rivnet_inters_dt[!is.na(cat), 
                 length_uid_fullsegper := length_uid/sum(length_uid),
                 by=UID_fullseg]

#For those segments where only one cat remains, assign cat to the entire segment
assign_singlecat_to_seg(rivnet_inters_dt)
cats_assigned <- rivnet_inters_dt[!is.na(cat_cor), unique(cat_cor)]

#For cats that are already assigned, remove their "cat" from other segments
rivnet_inters_dt[cat %in% cats_assigned & is.na(cat_cor), cat := NA]

#For segment sections in strahler==1 & n_seg_overlap > 2, cat := NA 
rivnet_inters_dt[strahler == 1 & n_seg_overlap > 2 & is.na(cat_cor), 
                 cat := NA] 

#if main representative of cat, assign cat_cor
rivnet_inters_dt[!is.na(cat_cor), cat := cat_cor]
rivnet_inters_dt[, length_cat := sum(length_uid), by=cat]
rivnet_inters_dt[, length_uid_catper := length_uid/length_cat, by=cat]
rivnet_inters_dt[length_uid_catper > 0.7 & is.na(cat_cor), cat_cor := cat]

#For cats that are already assigned, remove their "cat" from other segments
cats_assigned <- rivnet_inters_dt[!is.na(cat_cor), unique(cat_cor)]
rivnet_inters_dt[cat %in% cats_assigned & is.na(cat_cor), cat := NA]

#Re-compute length_uid_fullsegper, excluding segment sections whose initial
#cat was assigned elsewhere
rivnet_inters_dt[!is.na(cat_cor), 
                 length_uid_fullsegper := length_uid/sum(length_uid),
                 by=UID_fullseg]

##For those segments where only one cat remains, assign cat to the entire segment
#regardless of the proportion of the segment it represents
cat_cor_toassign <-  rivnet_inters_dt[
  is.na(cat_cor) & length_uid_fullsegper == 1,
  .(UID_fullseg, cat)] %>%
  setnames('cat', 'cat_cor')
rivnet_inters_dt[is.na(cat_cor), 
                 cat_cor := cat_cor_toassign[.SD, on='UID_fullseg', 
                                                   cat_cor]]

#For the remaining segments where all cats are NAs (have been assigned elsewhere), 
#assign the cat of the section representing the highest percent of the segment
#These are usually near loops that have been removed 
rivnet_inters_dt[is.na(cat_cor), NAlength := sum(length_uid),
                 by=UID_fullseg]
rivnet_inters_dt[(NAlength==length_fullseg), 
                 cat_cor := fifelse(length_uid == max(length_uid), cat_copy, NA), 
                 by=UID_fullseg]

#For all remaining sections, remove their "cat" 
rivnet_inters_dt[is.na(cat_cor), cat := NA]

for (i in 1:3) {
  #For segment section with cat==NAs and cat_cor==NA, 
  #assign cat_cor of upstream segment of same strahler order
  get_nearby_cat(rivnet_inters_dt, source_direction = 'upstream')
  
  #For is.na(cat) & is.na(cat_cor), 
  #assign downstream cat_cor of same UID_fullseg
  get_nearby_cat(rivnet_inters_dt, source_direction = 'downstream') 
  
}


#---------- Merge back with spatial data ---------------------------------------
#Merge processed attributes with pre-formatted spatial network
rivnet_catcor <- merge(
  rivnet_fullseg_inters_nopseudo, 
  rivnet_inters_dt[, .(UID, cat_cor, cat_copy)],
  by='UID') 

#Remove pseudo-nodes among segments sections of the same cat_cor
rivnet_catcor_smooth <- as_sfnetwork(rivnet_catcor) %>%
  activate(edges) %>%
  convert(to_spatial_smooth, 
          require_equal = c("cat_cor", "UID_fullseg"),
          summarise_attributes = "first") %>%
  st_as_sf()

#---------- Check results ------------------------------------------------------
#Compare with reaches data from hydrological model
#Format hydromod reaches data
in_reaches_dt <- in_reaches_hydromod_dt[, .(ID, to_reach, length)] %>%
  setnames(c('ID_hydromod', 'to_reach_hydromod', 'length_hydromod'))
#Merge data
to_reach_shpcor <- as.data.table(rivnet_catcor_smooth)[, .(from, cat_cor)] %>%
  setnames(c('to', 'to_reach_shpcor'))

rivnet_inters_check_dt <- merge(as.data.table(rivnet_catcor_smooth), 
                          to_reach_shpcor, by='to', all.x=T) %>%
  merge(in_reaches_dt, by.x='cat_cor', by.y='ID_hydromod', all.x=T)

rivnet_inters_check_dt[, hydromod_shpcor_match := (to_reach_hydromod == to_reach_shpcor)]

rivnet_inters_check_dt[(hydromod_shpcor_match==FALSE), .N]

#---------- Write out results ------------------------------------------------------
#Export results to gpkg
write_sf(rivnet_catcor[, c('UID', 'cat', 'strahler', 'UID_fullseg', 'cat_cor')],
         file.path(resdir, 'scratch.gdb'), layer=paste0('test_', in_country))
